#include "PGA.hh"

#include "eventInformation.hh"
#include "rootStorageManager.hh"

#include "G4SystemOfUnits.hh"
#include "G4PhysicalConstants.hh"
#include "G4Gamma.hh"
#include "G4Electron.hh"
#include "G4Geantino.hh"

#include <cmath>

#include "TFile.h"
#include "TROOT.h"
#include "TCanvas.h"
#include "TH1D.h"

PGA::PGA(int beamtype, int beammode, double beamoffset, int ptype)
{
  beamt = beamtype;
  beamo = beamoffset;
  bmode = beammode;

  genind = 0;

  // bizarre workaround to errors in loading in the TH2F's below
  // TCanvas *mydummycanvas=new TCanvas();
  TH1F* dummy = new TH1F("dummy", "dummy", 10, 0, 1);

  Random.SetSeed(0);

  TheSource = new G4ParticleGun();
  if (ptype==0)
    TheSource->SetParticleDefinition(G4Gamma::Definition());
  else if (ptype==1)
    TheSource->SetParticleDefinition(G4Geantino::Definition());
  else if (ptype==2)
    TheSource->SetParticleDefinition(G4Electron::Definition());
  else
  {
    G4cout<<"\n\nWARNING UNKNOWN PARTICLE TYPE!  DEFAULTING TO GAMMAS!\n\n";
    TheSource->SetParticleDefinition(G4Gamma::Definition());
  }

  TFile * fBrems = new TFile("output126um_2_521MeV_1uCnormalized.root");
  G4cout << "fBrems = " << fBrems << "\n";
  hBrems = (TH2D*)fBrems->Get("cosangleEnergyFar;1");
  //std::cout<<hBrems<<" "<<hBrems->FindBin(1.0,1.0)<<"\n";
  //std::cout<<"\n\n"<<hBrems->GetBinContent(hBrems->FindBin(1,1))<<"\n\n";
  //exit(0);

  // histogram sampling
  TFile *fBremsWeight = (TFile*) TFile::Open("brem_normalized.root");
  hBremsWeight = (TH1D*) fBremsWeight->Get("hBremsWeight");

  TFile *fSample = (TFile*) TFile::Open("hSample.root");
  hSample = (TH1D*) fSample->Get("hSample");

  TFile *fBinary = (TFile*) TFile::Open("hBinary.root");
  hBinary = (TH1D*) fBinary->Get("hBinary");

  //TFile *fSample = TFile::Open("hSample.root");
  //hSample = (TH2F*) fSample->Get("hSample");
}


PGA::~PGA()
{ delete TheSource; }


void PGA::GeneratePrimaries(G4Event *currentEvent)
{
  // G4double eSample, aSample;
  // hSample->GetRandom2(eSample, aSample);

  // circle beam generated by opening (half-)angle of ~5.6 degrees
  // given initial values of 90 mm radius at 913.8250 mm dist
  // compute the radius at a distance of (say) 400 mm for transmission target
//  G4double r1 = 90.0*mm;
//  G4double d1 = 913.8250*mm;
//  G4double d2 = 400*mm;
//  G4double r2 = d2*r1/d1;
//  G4double rSample = sqrt(Random.Uniform(0,1));
//  G4double thSample = Random.Uniform(0,2.0*pi);

  G4double pSample = Random.Uniform(0,2*M_PI);
  G4double costSample = 2*Random.Uniform(0.9975,1.0)-1; // so min is 0.995
  G4double tSample = acos(costSample);

  // Brem spectrum draw generation

  //double Einit = Random.Uniform(0.0,3.0);
  //G4double Einit = 2.17601067911*MeV; // for testing U-238
  //G4double Einit = 2.21210728352*MeV; // for testing Al-27
  //G4double Einit = hSample->GetRandom()*MeV;

  double Einit;
  if (beamt==0)
    Einit = Random.Uniform(1.9,2.3); //2.521*Random.Uniform(0.0,1);
  else if (beamt==1)
    Einit = SampleResonances();
  else if (beamt==2)
    Einit = 2.521;

  // Set the momentum direction
  G4ThreeVector pdir = G4ThreeVector(sin(tSample)*cos(pSample),sin(tSample)*sin(pSample),cos(tSample));

  TheSource->SetParticleEnergy(Einit);

  // Calculate beam position based on angle
//  G4double bphi = pSample; // Azimuthally symmetric beam cone
//  // Radius correlation parameters
//  G4double p1 = -0.0008112;
//  G4double p2 = -3.895e-05;
//  G4double br = (p2-sqrt(p2*p2-4*p1*(1-costSample)))/2/p1 + 0.75*(Einit-1.1555)*(Einit-2.521); // + Random.Gaus(0.0,3.0);; // Correlation plus energy/divergence correction + smear
//  G4double xSample = br*cos(bphi);
//  G4double ySample = br*sin(bphi);
//  G4ThreeVector pp = G4ThreeVector(xSample,ySample,14.2); // ySample, d2);
//  G4double zSample = 14.2;

  // New method projecting back from false_far
  G4double zfar = 946.845;
  G4double zcol = 998.9-780.0;
  G4double bphi = pSample; // Azimuthally symmetric beam cone
  G4double br = zfar*sqrt(1.0/costSample/costSample-1);
  G4double xSample = br*cos(bphi)*zcol/zfar;
  G4double ySample = br*sin(bphi)*zcol/zfar;
  G4ThreeVector pp = G4ThreeVector(xSample,ySample,zcol); // ySample, d2);
  G4double zSample = zcol;

  // pencil beam override for diagnostics
  //pp = G4ThreeVector(0,0,14.2);
  //pdir = G4ThreeVector(0,0,1);

  TheSource->SetParticlePosition(pp);
  // pp.setMag(1.0);
  // pdir = pp;
  TheSource->SetParticleMomentumDirection(pdir);

  // Det efficiency illumination
  if (bmode==1)
  {
    pSample = Random.Uniform(-0.5,0.5);// Random.Uniform(-M_PI/4,M_PI/2+M_PI);
    if (Random.Uniform(0,3.0)>2.0)
      pSample += M_PI; // Random.Uniform(2.9,3.6);
    costSample = 2*Random.Uniform(0.09,0.29)-1;
    tSample = acos(costSample);
    pdir = G4ThreeVector(sin(tSample)*cos(pSample),sin(tSample)*sin(pSample),cos(tSample));
    TheSource->SetParticleMomentumDirection(pdir);

    double rs = Random.Uniform(0,1);
    double ts = Random.Uniform(0,2*M_PI);
    double ppos = 998.9; // 1060.15; //
    double pt = 3.275; // 4.0/32.0*25.4; // 2.5*25.4; //
    if (Random.Uniform(0,2.0)>1.0)
    {
      ppos = 1060.15;
      pt = 2.5*25.4;
    }
    zSample = ppos+pt*(0.5-Random.Uniform(0,1));
    xSample = 65*(zSample/998.9)*sqrt(rs)*cos(ts);
    ySample = 65*(zSample/998.9)*sqrt(rs)*sin(ts);
    TheSource->SetParticlePosition(G4ThreeVector(xSample,ySample,zSample));
  }

  if (bmode==2)
  {
    pdir = G4ThreeVector(0.0,0.0,1.0);
    TheSource->SetParticleMomentumDirection(pdir);

    double rs = Random.Uniform(0,1);
    double ts = Random.Uniform(0,2*M_PI);
    xSample = 0.25*sqrt(rs)*cos(ts);
    ySample = 0.25*sqrt(rs)*sin(ts);
    TheSource->SetParticlePosition(G4ThreeVector(xSample,ySample,-100.0));
  }

  TheSource->GeneratePrimaryVertex(currentEvent);

  // calculate the weight
  G4int bin = hBrems->FindBin(Einit,costSample);
  // G4double s = hSample->GetBinContent(bin);
  // G4double p = hBrems->GetBinContent(bin);
  //G4double w = hBrems->GetBinContent(bin); // p/s;

  // Weight is the far histogram value times a corrections for the air
  // attenuation in the back propagation
  G4double w = hBrems->GetBinContent(bin);
  if (bmode==1 || bmode==2) w = 1.0;

  rootStorageManager * rm = rootStorageManager::GetInstance();

  if (bmode==0) rm->FillBremSampleTree(Einit, w);

  // std::cout<<"\n"<<TheSource->GetParticleMomentum()<<"\n";

//  // Electrons on target generation
//  double Einit = Random.Uniform(2.5);

//  // Set the momentum direction
//  G4ThreeVector pdir = G4ThreeVector(0,0,1);
//  TheSource->SetParticleEnergy(2.5);
//  TheSource->SetParticlePosition(G4ThreeVector(xSample, ySample, -5*mm));
//  TheSource->SetParticleMomentumDirection(pdir);
//  TheSource->GeneratePrimaryVertex(currentEvent);
//  G4double w = 1;
  
  
  // G4cout<<"\n\n********"<<Einit<<" "<<costSample<<" "<<w<<"********\n\n";

  // std::cout<<"Drawing event\n";

  // pass the event information up the chain
  eventInformation* anInfo = new eventInformation(currentEvent);
  anInfo->SetWeight(w);
  anInfo->SetBeamEnergy(Einit);
  anInfo->SetBeamAngle(pdir.theta());
  anInfo->SetVertexX(xSample);
  anInfo->SetVertexY(ySample);
  anInfo->SetVertexZ(zSample);
  anInfo->SetVertexTheta(pdir.theta());
  anInfo->SetVertexPhi(pdir.phi());
  anInfo->SetGeneratorIndex(genind);

  currentEvent->SetUserInformation(anInfo);

  genind++;
}

double PGA::SampleResonances()
{
  std::vector<double> er;
  er.push_back(2.176*MeV);
  er.push_back(2.209*MeV);
  er.push_back(2.245*MeV);
  er.push_back(2.212107*MeV);

  G4int idx = Random.Integer(er.size());
  G4double de = 50.0*eV;

  return Random.Uniform(er[idx]-de, er[idx]+de);
}
